
// src/ai/flows/interpret-musical-intent.ts
'use server';

/**
 * @fileOverview This file defines a Genkit flow to interpret user musical intent,
 * primarily from a free-text mood description and optional song/instrument filters.
 * It now focuses on generating a rich search query for Spotify.
 *
 * @exported
 * - `InterpretMusicalIntentInput`: The input type for the interpretMusicalIntent function.
 * - `InterpretMusicalIntentOutput`: The return type for the interpretMusicalIntent function.
 * - `interpretMusicalIntent`: The function that handles the musical intent interpretation process.
 */

import {ai} from '@/ai/genkit';
import {z}from 'genkit';
import { 
  searchSpotifyTrackService 
} from '@/services/spotify-service';

// +---------------------+
// |   INPUT SCHEMA      |
// +---------------------+
const InterpretMusicalIntentInputSchema = z.object({
  moodDescription: z.string().min(1, { message: 'Please describe the mood or vibe.' }),
  songName: z.string().optional().describe('An optional specific song name to influence the search query.'),
  instrumentTags: z.string().optional().describe('Optional comma-separated list of key instruments to include in the search query (e.g., guitar, piano).'),
});
export type InterpretMusicalIntentInput = z.infer<typeof InterpretMusicalIntentInputSchema>;

// +---------------------+
// |   OUTPUT SCHEMA     |
// +---------------------+
const InterpretMusicalIntentOutputSchema = z.object({
  fallbackSearchQuery: z.string().describe("A rich and descriptive search query string for Spotify. Example: 'upbeat electronic music with piano like the song Levitating for a summer road trip'")
}).describe("A search query for Spotify, generated by translating the user's vibe.");
export type InterpretMusicalIntentOutput = z.infer<typeof InterpretMusicalIntentOutputSchema>;


// +---------------------+
// |   GENKIT TOOLS      |
// +---------------------+

const getSpotifyTrackInfoTool = ai.defineTool(
  {
    name: 'getSpotifyTrackInfoTool',
    description: 'Searches Spotify for a track by name and returns its name and primary artist if found. Useful for creating "music like [song by artist]" queries.',
    inputSchema: z.object({ 
      trackName: z.string().describe("The name of the track to search for."),
    }),
    outputSchema: z.object({
        foundTrackName: z.string().nullable().describe("The Spotify track name, or null if not found."),
        foundArtistName: z.string().nullable().describe("The primary artist of the track, or null if not found."),
    }).nullable().describe("An object containing the track name and artist name, or null if track not found."),
  },
  async ({ trackName }) => {
    try {
      const tracks = await searchSpotifyTrackService(trackName, undefined, 1);
      if (tracks[0]) {
        return {
          foundTrackName: tracks[0].name,
          foundArtistName: tracks[0].artists[0]?.name || null,
        };
      }
      return null;
    } catch (error) {
      console.error("Error in getSpotifyTrackInfoTool:", error);
      return null;
    }
  }
);


// +---------------------+
// |   MAIN PROMPT       |
// +---------------------+

const interpretMusicalIntentPrompt = ai.definePrompt({
  name: 'interpretMusicalIntentPrompt',
  input: {schema: InterpretMusicalIntentInputSchema},
  output: {schema: InterpretMusicalIntentOutputSchema},
  tools: [getSpotifyTrackInfoTool],
  prompt: `You are an expert music curator. Your task is to translate the user's described mood, and any specific song/instrument preferences, into a rich, descriptive search query for Spotify. This query should capture the *essence* and *musical characteristics* of the desired vibe.

User's Core Vibe Description: "{{{moodDescription}}}"

Consider the following additional information if provided:
Preferred Song Name: {{{songName}}}
Preferred Instruments: {{{instrumentTags}}}

You have access to the following tool:
- \`getSpotifyTrackInfoTool({ trackName: string })\`: Searches for a track by its name. If found, it returns the track's name and primary artist's name.

Based on ALL the information above, please return a JSON object matching the InterpretMusicalIntentOutputSchema, containing a single \`fallbackSearchQuery\` field.

Detailed Instructions for constructing the \`fallbackSearchQuery\`:
1.  **Analyze Vibe Musically**: Deeply analyze the user's \`moodDescription\`. Consider elements like tempo (e.g., 'slow electronic music', 'uptempo funk'), energy level (e.g., 'calm ambient pieces', 'high-energy rock anthems'), instrumentation (e.g., 'acoustic guitar ballads', 'songs with prominent synths'), vocal style (e.g., 'instrumental focus tracks', 'songs with powerful vocals'), and overall atmosphere (e.g., 'dreamy soundscapes', 'intense workout tracks', 'melancholic indie folk', 'joyful pop').

2.  **Song Name Integration**: If a \`songName\` (like '{{songName}}') is provided, use the \`getSpotifyTrackInfoTool\` to find its official name and artist.
    *   If found, construct a query that seeks music *similar in vibe* to that track, while still respecting the user's overall \`moodDescription\`. For example: "music for {{{moodDescription}}} with a vibe like '{{foundTrackName}}' by '{{foundArtistName}}'".
    *   If not found, but the \`songName\` seems descriptive, you can still incorporate it, e.g., "music for {{{moodDescription}}} like '{{songName}}'".

3.  **Instrument Integration**: If \`instrumentTags\` (e.g., '{{instrumentTags}}') are provided, weave them naturally into the descriptive query, for example: "music for {{{moodDescription}}} featuring {{instrumentTags}}".

4.  **Combine Naturally**: Construct a single, natural language query. The query should be a phrase that a human music enthusiast would type into Spotify. Aim for 3 to 7 significant terms or phrases for optimal Spotify search results.
    *   Good Example: "Atmospheric electronic music for a late night drive, featuring dreamy synths, similar to 'Strobe' by deadmau5"
    *   Bad Example: "late_night_drive electronic dreamy synth strobe deadmau5"

5.  **Fallback**: If the \`moodDescription\` is extremely vague and no other specific information is provided, create a general but still somewhat descriptive query like "popular upbeat electronic music" or "trending indie folk songs". Avoid generic "popular music" if possible.

IMPORTANT: The output MUST be a JSON object with only the \`fallbackSearchQuery\` field, containing the constructed search string.
Example Output:
{
  "fallbackSearchQuery": "upbeat pop dance music with synth for summer road trip like 'Blinding Lights' by The Weeknd"
}
Ensure the output is valid JSON matching the schema.
`,
});

// +---------------------+
// |   FLOW DEFINITION   |
// +---------------------+
const interpretMusicalIntentFlow = ai.defineFlow(
  {
    name: 'interpretMusicalIntentFlow',
    inputSchema: InterpretMusicalIntentInputSchema,
    outputSchema: InterpretMusicalIntentOutputSchema,
  },
  async (input) => {
    console.log("interpretMusicalIntentFlow (free-text mood) input:", JSON.stringify(input));
    const {output} = await interpretMusicalIntentPrompt(input);

    if (!output || !output.fallbackSearchQuery || output.fallbackSearchQuery.trim() === "") {
        console.warn("AI prompt 'interpretMusicalIntentPrompt' did not return a valid fallbackSearchQuery for input:", input, "Generated output:", JSON.stringify(output));
        let fallback = `music for ${input.moodDescription || 'discovery'}`;
        if (input.instrumentTags && fallback && input.instrumentTags.trim() !== '') {
            if (!fallback.toLowerCase().includes(input.instrumentTags.toLowerCase())) {
                 fallback += ` with ${input.instrumentTags}`;
            }
        }
         if (input.songName && fallback && input.songName.trim() !== '') {
            if (!fallback.toLowerCase().includes(input.songName.toLowerCase())) {
                 fallback += ` like ${input.songName}`;
            }
        }
        if (fallback.trim() === "music for discovery") fallback = "popular music"; // Last resort
        return { fallbackSearchQuery: fallback.trim() };
    }
    
    console.log("interpretMusicalIntentFlow (free-text mood) output:", JSON.stringify(output));
    return output;
  }
);

// +---------------------+
// | EXPORTED FUNCTION   |
// +---------------------+
export async function interpretMusicalIntent(input: InterpretMusicalIntentInput): Promise<InterpretMusicalIntentOutput> {
  return interpretMusicalIntentFlow(input);
}
